* Org and GitHub                                                   :noexport:
This README you're looking at right now is an [[https://orgmode.org/][org]] document. GitHub have parsed it into their custom extended markdown
format for your convenience, and they haven't done it very well.

If you want working links to headings, footnotes, centered text, proper line wrapping in code markup and so forth; you
should clone this repo and check out [[./branchless_fizzbuzz.html]], or open this file with [[https://www.gnu.org/software/emacs/download.html][GNU Emacs]].
* Introduction
** Rationale
Okay, so a couple years back I was reading this great blog post titled "Euler's Fizzbuzz" (which you can find here:
http://philcrissman.net/posts/eulers-fizzbuzz/, read it!), which describes a really interesting technique for
differentiating numbers by their prime factors with only simple integer arithmetic. One line of that post in particular,
right at the start, has stuck in my mind for over a year since I fist read it:

#+begin_quote
It is possible to write a function which uses no conditional logic at all, but which uses math to separate integers into
4 possible categories:

1. Those which have 3 as a factor, but not 5
2. Those which have 5 as a factor, but not 3
3. Those which have both 3 and 5 as a factor
4. Those which have neither 3 nor 5 as factors
#+end_quote

It's that "no conditional logic" bit that caught my attention. If we can differentiate numbers based on their prime
factors, we can use a lookup table to determine what to output for that number ('Fizz', 'Buzz', 'FizzBuzz', or the
i-to-a representation of the input); and since for every lookup table, there's an equivalent implementation with logic
gates (and vice versa), we can implement the whole function without conditional logic. That means no branches, no tests,
and no comparisons. I wanted to give that a try.

-----

To be more specific, we're not going to do any of the following in our implementation logic:

- branch,
- jump,
- call,
- syscall,
- or otherwise modify the state of  ~rip~ in any way besides advancing it to the next instruction;
- ~mov~ any data from memory to anywhere else;
- perform an indirection of any form other than ~[rdi] + disp64~,
- or mutate ~rdi~.

That means we need someone else (less pure) to do stuff like I/O for us. I've implemented
* Hardcoded Data Structure Sizes
First, before we do anything else, we need to pick a size to hard-code for our output buffer.

At present, this is constrained such that it should be at least $\text{len}(\text{“FizzBuzz\\0”}) + \lceil \log_{10}
(2^{64} - 1) \rceil + 1 = 30$ bytes big, if we want to support all unsigned 64-bit integers.

#+begin_src nasm :tangle yes
  %assign BUFF_SIZE 30
#+end_src
* ~bfb_fill_buffer~
Okay, now we define our text section and function label headers:

#+begin_src nasm :tangle yes
  section .text

  global bfb_fill_buffer
  bfb_fill_buffer:
#+end_src

This is a function that takes two arguments: a buffer to write the result to (must be at least ~30~ characters big), and
the number to process. It returns nothing.

Let's define that in a header file:

#+begin_src c :tangle branchless_fizzbuzz.h
  #ifndef BRANCHLESS_FIZZBUZZ_H
  #define BRANCHLESS_FIZZBUZZ_H

  // #include <stddef.h>   // ensure size_t is defined
  #include <stdint.h>   // ensure uint64_t is defined

  #define MIN_BUFFER_SIZE 30

  void bfb_fill_buffer(char*, uint64_t);

  #endif
#+end_src

Let's start implementing our logic:

The following registers are used by this program:

| Name  | Purpose                                                                                    |
|-------+--------------------------------------------------------------------------------------------|
| ~rdi~ | Contains the 1st argument (output buffer) on entry, used as the "write" pointer for output |
|-------+--------------------------------------------------------------------------------------------|
| ~rsi~ | Contains the 2nd argument (the number to process) on entry, held that way                  |
|-------+--------------------------------------------------------------------------------------------|
| ~rax~ | Miscellaneous                                                                              |
|-------+--------------------------------------------------------------------------------------------|
| ~rcx~ | Miscellaneous                                                                              |
|-------+--------------------------------------------------------------------------------------------|
| ~rdx~ | Miscellaneous                                                                              |
|-------+--------------------------------------------------------------------------------------------|
| ~r8~  | Miscellaneous                                                                              |
|-------+--------------------------------------------------------------------------------------------|
| ~r11~ | Miscellaneous                                                                              |

#+begin_center
The x64 ABI states that callees must preserve the values of ~rbx~, ~rsp~, ~rbp~, and ~r12~-~15~, as well as some
floating-point registers. We use none of them.
#+end_center

First, we need to perform an integer-to-string conversion on ~rsi~. The following is a naive implementation which
prefixes the result with 00000s to fill the buffer:

#+begin_center
Registers:

#+ATTR_HTML: :align center
| Name  | Purpose                                              |
|-------+------------------------------------------------------|
| ~rdi~ | Immutable write-to-output-buffer pointer             |
|-------+------------------------------------------------------|
| ~rax~ | Quotient of each division step                       |
|-------+------------------------------------------------------|
| ~rcx~ | Set to the constant '10' for base 10 and not changed |
|-------+------------------------------------------------------|
| ~rdx~ | Remainder of each division                           |

#+end_center

#+begin_src nasm :tangle yes
  ;; initial setup
          mov rax, rsi            ; move our number into the bottom half of the same
          mov rcx, 10             ; our base
  ;; repeat for every digit
  %assign i BUFF_SIZE - 2
  %rep BUFF_SIZE - 8 - 1 - 1
          xor rdx, rdx            ; zero the top half of rdx:rax
          div rcx                 ; rax now contains the quotient, and rdx the remainder
          add rdx, '0'
          mov byte [rdi + i], dl
  %assign i i-1
  %endrep
  ;; cleanup
          mov byte [rdi + BUFF_SIZE - 1], 0 ; null-terminate the buffer
#+end_src

Next, we need to use [[http://philcrissman.net/posts/eulers-fizzbuzz/][this]] algorithm to differentiate whether ~3~, ~5~, both, or /neither/ are factors of ~rsi~:

#+begin_center
Registers:

#+ATTR_HTML: :align center
| Name  | Purpose                           |
|-------+-----------------------------------|
| ~rsi~ | Current FizzBuzz iteration number |
|-------+-----------------------------------|
| ~rax~ | Quotient of each division step    |
|-------+-----------------------------------|
| ~rdx~ | Result of the procedure           |
|-------+-----------------------------------|
| ~rcx~ | Magic modulus constant            |

#+end_center

#+begin_src nasm :tangle yes
          xor rdx, rdx            ; zero upper half of rdx:rax
          mov rax, rsi            ; rdx:rax = rsi^1
          mul rsi                 ; rdx:rax = rsi^2
          mul rsi                 ; rdx:rax = rsi^3
          mul rsi                 ; rdx:rax = rsi^4
          mov rcx, 15
          div rcx                 ; final remainder is now in rdx
#+end_src

#+begin_center
(We ~mul~ with ~rsi~ three times, instead of ~mul rax~ two times, because the latter will work for all 64-bit integers.)
#+end_center

Now the ~rdx~ register will contain one of four possible values:

| dec  | bin        | IFF...                                           |
| <l>  | <l>        | <l>                                              |
| /    | >          | >                                                |
|------+------------+--------------------------------------------------|
| ~0~  | ~00000000~ | ...​~rsi~ is divisible by ~3~ and ~5~            |
| ~1~  | ~00000001~ | ...​~rsi~ is coprime to ~3~ and ~5~              |
| ~6~  | ~00000110~ | ...​~rsi~ is divisible by ~3~ and coprime to ~5~ |
| ~10~ | ~00001010~ | ...​~rsi~ is coprime to ~~3 and divisible by ~5~ |

We'll use this to write the "head" of the buffer as follows:

| ~dl~ | byte 0 | 1     | 2     | 3     | 4      | 5     | 6     | 7       | 8      |
|    / | <      |       |       |       |        |       |       |         | >      |
|------+--------+-------+-------+-------+--------+-------+-------+---------+--------|
|    0 | ~'F'~  | ~'i'~ | ~'z'~ | ~'z'~ | ~'B'~  | ~'u'~ | ~'z'~ | ~'z'~   | ~NULL~ |
|    1 | ~'0'~  | ~'0'~ | ~'0'~ | ~'0'~ | ~'0'~  | ~'0'~ | ~'0'~ | ~'0'~   | ~'0'~  |
|    6 | ~'F'~  | ~'i'~ | ~'z'~ | ~'z'~ | ~NULL~ | what  | ever  | doesn't | matter |
|   10 | ~'B'~  | ~'u'~ | ~'z'~ | ~'z'~ | ~NULL~ | what  | ever  | doesn't | matter |

#+begin_center
(For reference, here's the binary values for each of those ASCII codepoints:)

#+ATTR_HTML: :align center
| /      | >          |       | >          |
| ~NULL~ | ~00000000~ | ~'0'~ | ~00110000~ |
| ~'B'~  | ~01000010~ | ~'F'~ | ~01000110~ |
| ~'i'~  | ~01101001~ | ~'u'~ | ~01110101~ |
| ~'z'~  | ~01111010~ |       |            |

#+end_center

But before we do any of that, we'll copy the value in ~rdx~ to ~rcx~ for safekeeping.

#+begin_src nasm :tangle yes
          mov rcx, rdx
#+end_src

Alright, let's get started.

For bytes 2, 3, 6, 7, and 8; we only need to discriminate depending on if ~rdx~ is equal to ~1~, writing a ~'0'~ if so,
and a ~'z'~ if not.

#+begin_center
Registers:

#+ATTR_HTML: :align center
| Name  | Purpose                                                   |
|-------+-----------------------------------------------------------|
| ~rdi~ | Immutable write-to-output-buffer pointer                  |
|-------+-----------------------------------------------------------|
| ~rcx~ | Immutable copy of the "Euler's FizzBuzz" procedure result |
|-------+-----------------------------------------------------------|
| ~rdx~ | Value to write to bytes 2, 3, 6 and 7                     |
|-------+-----------------------------------------------------------|
| ~rax~ | Value to write to byte 8                                  |

#+end_center

#+begin_src nasm :tangle yes
  ;; determine if rdx (rcx) is 1 or not
          mov rdx, rcx            ; restore rdx
          dec edx
          neg rdx
          shr rdx, 63             ; rdx is now 00h if it was 1, and 01h otherwise
          dec rdx
          not rdx                 ; rdx is now 00h if it was 1, and FFFFFFFFFFFFFFFFh otherwise

  ;; set rax to '0' if rdx is 1, and NULL otherwise
          mov rax, rdx
          not rax
          and rax, '0'

  ;; set rdx to '0' if it was 1, and 'z' otherwise
          and rdx, 'z' - '0'
          add rdx, '0'

  ;; write our bytes
          mov byte [rdi + 2], dl
          mov byte [rdi + 3], dl
          mov byte [rdi + 6], dl
          mov byte [rdi + 7], dl
          mov byte [rdi + 8], al
#+end_src

For byte 4, we can use bit position 1 in ~rdx~ to distinguish ~6~ and ~10~ from ~0~ and ~1~ (it's set in the former and
unset in the latter), and ~1~ from ~0~ with bit position 0 (only set in the former, obviously).

Once again, we are conveniently aided by the fact that 'B' and '0' are disjoint. We can simply compose the result byte
from a single conditional mask, toggling it between applications, and then if it's actually supposed to be NULL, we just
zero the byte with another conditional mask. (Regardless of whatever garbage may have been created.)

#+begin_center
Registers:

#+ATTR_HTML: :align center
| Name  | Purpose                                                   |
|-------+-----------------------------------------------------------|
| ~rdi~ | Immutable write-to-output-buffer pointer                  |
|-------+-----------------------------------------------------------|
| ~rcx~ | Immutable copy of the "Euler's FizzBuzz" procedure result |
|-------+-----------------------------------------------------------|
| ~rdx~ | Scratch register, used to compose conditional masks       |
|-------+-----------------------------------------------------------|
| ~rax~ | Value to write to byte 4                                  |

#+end_center

#+begin_src nasm :tangle yes
          mov rdx, rcx            ; restore rdx
          xor rax, rax            ; zero rax, we'll compose our result in here
  ;; set up as though this weren't 6 or 10
          dec rdx                 ; rdx is now 00h if it was 1, and FFFFFFFFFFFFFFFFh if it was 0
          mov rax, 'B'
          and rax, rdx            ; rax is now 'B' if rdx was 0 and 00h if rdx was 1
          not rdx
          and rdx, '0'
          or rax, rdx             ; rax is now '0' if rdx was 1 and unchanged if rdx was 0
  ;; "is it 0 or 1" mask
          mov rdx, rcx            ; restore rdx
          and rdx, 00000010b
          sub rdx, 00000010b      ; rdx is now 00h if it was > 1, else FFFFFFFFFFFFFFFFh
          and rax, rdx            ; rax is now 00h (NULL) if rdx was > 1
  ;; write our byte
          mov byte [rdi + 4], al

#+end_src

Finally, for bytes 0, 1 and 5, we need to discriminate based on whether ~rdx~ is equal to ~1~, ~10~, or if it's equal to
~0~ or ~6~. To distinguish ~0~ and ~6~ from ~1~ and ~10~, we can decrement ~rdx~ and check if bit 2 is ~1~. If it is,
it's ~0~ or ~6~.

| ~dl~       | ~dl - 1~   |
|------------+------------|
| ~00000000~ | ~11111111~ |
| ~00000001~ | ~00000000~ |
| ~00000110~ | ~00000101~ |
| ~00001010~ | ~00001001~ |

To distinguish ~1~, we only have to look at the 0th bit of ~rdx - 1~: it'll be set if it was ~0~, ~6~ or ~10~, and unset
if it was ~1~.

From these two bit positions, we can calculate the proper character value. Conveniently, we can turn ~'B'~ into ~'F'~ by
setting the very same bit position, and the bits of ~'0'~ are mutually exclusive with those of either. /Unfortunately,/
'i' and 'u' are overlapping non-subsets. 'u' /is/ a superset of '0', though.

This logic is pretty involved; fortunately, since these are the last bytes and we don't need to restore ~rdx~ anymore,
we can afford to clobber ~rcx~ for another non-REX scratch register.

#+begin_center
Registers:

#+ATTR_HTML: :align center
| Name  | Purpose                                                      |
|-------+--------------------------------------------------------------|
| ~rdi~ | Immutable write-to-output-buffer pointer                     |
|-------+--------------------------------------------------------------|
| ~rcx~ | Copy of the "Euler's FizzBuzz" procedure result,             |
|       | later re-used as the bit-unset mask for both-coprime results |
|-------+--------------------------------------------------------------|
| ~rdx~ | Scratch, used to compose conditional masks                   |
|-------+--------------------------------------------------------------|
| ~rax~ | Value to write to byte 0                                     |
|-------+--------------------------------------------------------------|
| ~r8~  | Value to write to byte 1                                     |
|-------+--------------------------------------------------------------|
| ~r11~ | Value to write to byte 5                                     |

#+end_center

#+begin_src nasm :tangle yes
  ;; is it 0 or 6? or is it something else?
          dec rcx
          mov rax, rcx
          and rax, 00000100b      ; rax now contains 04h if rcx was 0 or 6, and 00h if it was 1 or 10
          mov rdx, rax
          or rax, 'B'             ; rax now contains 'F' if rcx was 0 or 6, and 'B' if it was 1 or 10

          shr rdx, 2
          dec rdx                 ; rdx now contains 00h if rcx was 0 or 6, and FFFFFFFFFFFFFFFFh if it was 1 or 10
          mov r8, 'u' - '0'
          and r8, rdx             ; r8 now contains 'u' - '0' if rcx was 1 or 10, and 00h if it was 0 or 6
          not rdx
          mov r11, rdx
          and rdx, 'i' - '0'
          or r8, rdx              ; r8 now contains 'i' - '0' if rcx was 0 or 6, and is unchanged if it was 1 or 10

          and r11, 'u'
          or r11, '0'              ; r11 now contains 'u' if rcx was 0 or 6, and '0' if it was 1 or 10
  ;; write byte 5
          mov byte [rdi + 5], r11b

  ;; but was it 1 all along?
          not rcx
          and rcx, 00000001b      ; rcx now contains 01h if it was 1, and 00h otherwise
          dec rcx                 ; rcx now contains 00h if our initial rcx value was 1, and FFFFFFFFFFFFFFFFh otherwise

          and r8, rcx
          add r8, '0'             ; r8 now contains '0' if our initial rcx value was 1, 'u' if it was 10, and 'i' if it was 0 or 6

  ;; write byte 1
          mov byte [rdi + 1], r8b

  ;; wrap up "was it 1 all along?"
          not rcx                 ; rcx now contains FFFFFFFFFFFFFFFFh if our initial rcx value was 1, and 00h otherwise

          mov rdx, rcx
          and rdx, '0'            ; our *set* mask
          and rcx, rax            ; our *unset* mask


          xor rax, rcx            ; sets rax to 0 if our initial rcx value was 1, otherwise leaves it unchanged
          or rax, rdx             ; sets rax to '0' if our initial rcx value was 1, otherwise leaves it unchanged

  ;; write byte 0
          mov byte [rdi], al
#+end_src

And with that, we're all done!

#+begin_src nasm :tangle yes
          ret
#+end_src
* The Driver
Since this function implementation has no I/O or entry point, we need a small "driver" program to interface with it and
print the results. Here's a simple one:

#+begin_src c :tangle driver.c
  #include <stdint.h>
  #include <stdio.h>
  #include <stdlib.h>

  #include "branchless_fizzbuzz.h"

  int main(int argc, char* argv[]) {
      char buffer[MIN_BUFFER_SIZE] = {0};

      // could be unrolled and moved into the assembly (thereby eliminating a source of branches) if we're willing to hard
      // code the loop bound, but for the sake of the binary's size we're not gonna do that.
      for (uint64_t i = 1; i != 1000; i++) {
          bfb_fill_buffer(buffer, i);

          puts(buffer);
      }
  }
#+end_src
