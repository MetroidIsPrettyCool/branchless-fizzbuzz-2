* What's the deal?
A FizzBuzz implementation with...

- No branches
- No jumps
- No calls (except to the function itself)
- No ~mov~ instructions where the source is a location in memory
- No indirection not of the form ~[rdi] + disp64~
- No mutating ~rdi~

in the "should we print Fizz, Buzz, FizzBuzz, or the number?" logic. It's all just bitwise manipulation and regular
algebra; implemented in x64 assembly, so I can be sure the compiler isn't putting in any branches or memory indirects
behind my back. Inspired by [[http://philcrissman.net/posts/eulers-fizzbuzz/][this really cool blog post]].

See [[./src/branchless_fizzbuzz.org]] (or [[./src/branchless_fizzbuzz.html]]) for the low-level description, it contains the
whole literate org-tangled source code for the project, intermixed with all my notes.
* Building
Run ~make~ in the repository root. Requires YASM, gcc and make. ~./build/branchless_fizzbuzz~ will run the binary.

To remove all build products, run ~make clean~. To remove all build products and the binary, run ~make pristine~.
* Potential Further Improvements
1. Have the assembly portion return a pointer the beginning of the string, instead of just /assuming/ it's the same as
   the start of the buffer. Would allow us to elide all those leading 0s.
2. Replace the loop in the C driver with a ~%rep~ loop in the assembly portion of the project. If taken with #1, would
   probably involve passing a pair of buffers: one to write data to, and another to write pointers to the starts of each
   string. First buffer should probably be 32-byte aligned.
3. Get better at assembly and find better and arcane-er ways to implement everything.
