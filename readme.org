* What's the deal?
This is a pretty simple implementation of 'FizzBuzz' in Linux x64 assembly. It contains no conditional branches (not in
the binary, anyway) and implements all logic via lookup tables and an ingenious little algorithm borrowed from
http://philcrissman.net/posts/eulers-fizzbuzz/, which immediately captured my attention the moment I started reading
it. It's such an elegant idea!

There are two reasons I decided to implement this in assembly:

1. Attempting to implement the conditional logic-less algorithm in a language like C or Python or Ada or Bash or what
   have you strikes me as cheating. The whole point of this is to avoid branching! Even C doesn't give us enough
   control. Too many opportunities for glibc or CRT0.o to get statically linked and introduce unwanted instructions into
   our otherwise "pure" binary.

   Furthermore, standard C doesn't really have any good code-repeat macros, and ~for~​/​~while~ loops are unquestionably
   branches. Infinite goto loops are fine, but I wanted the program to halt on its own so as not to fill up my eshell
   buffer too quickly and hang my editor. (Yeah it's a cop-out but I'm sticking to it.)
2. I have very little x64 assembly experience, so I wanted to write more small but non-trivial (well, /less/ trivial)
   programs to experiment with style, continue to familiarize myself with the Intel developer's guide, and the NASM
   documentation.

   You may notice, for example, that I've adopted a sort of "Hungarianesque" notation for my labels -- the result of
   which is kind of ugly and uncoordinated. Better to know 'cause you've tried it than not!

   I've also overused ~align~ directives in ~.data~ and ~.rodata~. Those are there entirely because I hadn't used
   ~align~ before and wanted to tinker with it a little.
* Building
Run ~make~, ~make all~ or ~make branchless-fizzbuzz~ in the top (well, only) folder of the repo to build the
executable. Requires NASM, ld and make. ~./branchless-fizzbuzz~ will run the binary.

Running ~./quick-regression-test.sh~ will compare the output to a file called ~expected.txt~ and report "regression!" if
they're different, else "no regression".

To remove all build products, run ~make clean~. To remove all build products and the binary, run ~make pristine~.
* Potential Further Improvements
1. Refactor out the lookup tables. LUTs are conditionals in all but name. Ideally there should be no memory indirection
   outside of: as a parameter for ~SYS_WRITE~, itoa, and temporary variable storage.
2. Settle on and standardize a saner name format for labels.
3. Remove various bits of redundancy.
4. Clean up makefile. It was a hack job just to get the thing to build, and it's not up my personal standards.
5. Further extensibility to other prime number-word associations. (Compiler, anyone?)
* Other Notes
Yes, I know that "branchless" is a misnomer here. This is not "branchless fizzbuzz" but instead
"conditional-branches-in-userspace-less fizzbuzz" There are 3,000 ~call~ instructions, 3,000 ~ret~ instructions and
1,001 ~syscall~ instructions in the assembled binary, and behind the x64 ~syscall~ API there are doubtless hundreds and
thousands of conditional and unconditional branches going on in ring 0.

FWIW: ~itoa~ could be trivially inlined, and ~fizzorbuzzorbothorneither~ (verbose on purpose, I thought it was funny)
could be inlined without too much difficulty -- though doing so would inflate the resulting binary quite a bit (from
20,776 to 91,936 bytes as of my last test) -- which would leave us with only the ~syscall~​s.

There is, to my knowledge, no way to do any kind of I/O in userspace without ~syscall~​s. We could batch our writes and
reduce their number, but we can't eliminate them entirely.

Still, this program only ever executes ~syscall~ after setting ~rax~ to an immediate, which upholds the "no conditional
logic in userspace" part of "branchless", for whatever that's worth.
