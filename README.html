<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-13 Sat 20:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgf3782e5">1. Introduction</a>
<ul>
<li><a href="#orgb9d525d">1.1. Rationale</a></li>
</ul>
</li>
<li><a href="#org74b8530">2. Implementation</a>
<ul>
<li><a href="#orgbf15988">2.1. Overview</a></li>
<li><a href="#org79d0c0a">2.2. The Driver</a></li>
<li><a href="#org45603cb">2.3. <code>bfb_fill_buffer</code></a>
<ul>
<li><a href="#orgebaf028">2.3.1. Setup</a></li>
<li><a href="#org802cb85">2.3.2. i to a</a></li>
<li><a href="#org44855b6">2.3.3. Euler&rsquo;s FizzBuzz</a></li>
<li><a href="#orgd711518">2.3.4. Logic Strategies</a></li>
<li><a href="#org4905f12">2.3.5. &ldquo;Coprime to Both or Not&rdquo;-Specific Bytes</a></li>
<li><a href="#org45e721f">2.3.6. Byte 4</a></li>
<li><a href="#org39d4c13">2.3.7. &ldquo;Fizz vs Buzz vs <code>itoa</code>&rdquo;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf75023c">3. Building</a></li>
<li><a href="#orgf9cc34a">4. Potential Further Improvements</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgf3782e5" class="outline-2">
<h2 id="orgf3782e5"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgb9d525d" class="outline-3">
<h3 id="orgb9d525d"><span class="section-number-3">1.1.</span> Rationale</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Okay, so a couple years back I was reading this great blog post titled &ldquo;Euler&rsquo;s Fizzbuzz&rdquo; (which you can find here:
<a href="http://philcrissman.net/posts/eulers-fizzbuzz/">http://philcrissman.net/posts/eulers-fizzbuzz/</a>, read it!), which describes a really interesting technique for
differentiating numbers by their prime factors with only simple integer arithmetic. One line of that post in particular,
right at the start, has stuck in my mind for over a year since I fist read it:
</p>

<blockquote>
<p>
It is possible to write a function which uses no conditional logic at all, but which uses math to separate integers into
4 possible categories:
</p>

<ol class="org-ol">
<li>Those which have 3 as a factor, but not 5</li>
<li>Those which have 5 as a factor, but not 3</li>
<li>Those which have both 3 and 5 as a factor</li>
<li>Those which have neither 3 nor 5 as factors</li>
</ol>
</blockquote>

<p>
&ldquo;No conditional logic&rdquo;, huh?
</p>

<p>
Well, it follows from that, that if we can differentiate numbers based on their prime factors, we can use a lookup table
to determine what to output for that number (&rsquo;Fizz&rsquo;, &rsquo;Buzz&rsquo;, &rsquo;FizzBuzz&rsquo;, or the i-to-a representation of the input); and
since for every lookup table, there&rsquo;s an equivalent implementation with logic gates (and vice versa), we can implement
the whole function without conditional logic. That means no branches, no tests, and no comparisons.
</p>

<p>
I wanted to give that a try.
</p>

<hr />

<p>
To be more specific, we&rsquo;re not going to do any of the following in our implementation logic:
</p>

<ul class="org-ul">
<li><code>jcc</code> (or family),</li>
<li><code>jmp</code> (or family),</li>
<li><code>rep</code> (or family),</li>
<li><code>call</code> (or family),</li>
<li><code>syscall</code>, <code>int</code>, or any other kind of trap (conditional or otherwise),</li>
<li>or anything else that mutates <code>rip</code> in any ways besides advancing it to the next instruction;</li>
<li><code>mov</code> any data from memory to anywhere else;</li>
<li>perform an indirection of any form other than <code>[rdi] + disp64</code> (implicit or otherwise; that means <code>push</code> and <code>movs</code>
and so forth),</li>
<li><i>or</i> mutate <code>rdi</code> at any point, for any reason.</li>
</ul>

<p>
That means we&rsquo;re gonna need something less pure to do stuff like I/O for us. We&rsquo;ll get to that.
</p>
</div>
</div>
</div>
<div id="outline-container-org74b8530" class="outline-2">
<h2 id="org74b8530"><span class="section-number-2">2.</span> Implementation</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgbf15988" class="outline-3">
<h3 id="orgbf15988"><span class="section-number-3">2.1.</span> Overview</h3>
<div class="outline-text-3" id="text-2-1">
<p>
This project is split into two source files: an impure driver written in C, which implements the outer loop and printing
logic; and a comparison-less function written in x64 assembly (to avoid the compiler doing anything against the rules
behind our backs), which implements the following pseudocode logic:
</p>

<pre class="example" id="org1e7c717">
if n % 3 == 0 &amp;&amp; n % 5 != 0:
  return "Fizz"
if n % 3 != 0 &amp;&amp; n % 5 == 0:
  return "Buzz"
if n % 3 == 0 &amp;&amp; n % 5 == 0:
  return "FizzBuzz"
if n % 3 != 0 &amp;&amp; n % 5 != 0:
  return itoa(n)
</pre>
</div>
</div>
<div id="outline-container-org79d0c0a" class="outline-3">
<h3 id="org79d0c0a"><span class="section-number-3">2.2.</span> The Driver</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The implementation of the driver is pretty simple. We import some standard headers:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #d33682;">#include</span> <span style="color: #2aa198;">&lt;stdio.h&gt;</span>
<span style="color: #d33682;">#include</span> <span style="color: #2aa198;">&lt;stdlib.h&gt;</span>

<span style="color: #d33682;">#include</span> <span style="color: #2aa198;">&lt;stdint.h&gt;</span>
</pre>
</div>

<p>
and then our project-specific header (which we&rsquo;ll cover in a sec.), to link against the assembly source:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #d33682;">#include</span> <span style="color: #2aa198;">"branchless_fizzbuzz.h"</span>
</pre>
</div>

<p>
and then we just allocate a character buffer for our assembly function, call it in a loop, and print each result:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #268bd2;">int</span> <span style="color: #b58900;">main</span>(<span style="color: #268bd2;">int</span> <span style="color: #6c71c4;">argc</span>, <span style="color: #268bd2;">char</span>* <span style="color: #6c71c4;">argv</span>[]) {
    <span style="color: #268bd2;">char</span> <span style="color: #6c71c4;">buffer</span>[MIN_BUFFER_SIZE] = {0};

    <span style="color: #859900;">for</span> (<span style="color: #268bd2;">uint64_t</span> <span style="color: #6c71c4;">i</span> = 1; i != 1000; i++) {
        bfb_fill_buffer(buffer, i);

        puts(buffer);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org45603cb" class="outline-3">
<h3 id="org45603cb"><span class="section-number-3">2.3.</span> <code>bfb_fill_buffer</code></h3>
<div class="outline-text-3" id="text-2-3">
<p>
Implementing <code>bfb_fill_buffer</code> is, of course, significantly more involved.
</p>

<p>
First, let&rsquo;s define our parameters. As you can see, we need two things from the driver: a buffer to write to, and the
iteration number to process. Both are 64-bit; the former a pointer, the latter simply an unsigned integer. Let&rsquo;s define
that in our header file:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #d33682;">#include</span> <span style="color: #2aa198;">&lt;stdint.h&gt;</span>   <span style="color: #93a1a1; font-style: italic;">// </span><span style="color: #93a1a1; font-style: italic;">ensure uint64_t is defined
</span>
<span style="color: #268bd2;">void</span> <span style="color: #b58900;">bfb_fill_buffer</span>(<span style="color: #268bd2;">char</span>*, <span style="color: #268bd2;">uint64_t</span>);
</pre>
</div>

<p>
We also need to hardcode the size of the buffer, as without conditional logic we have no means to terminate loops &#x2013;
everything is gonna have to be unrolled. This is constrained by our implementation logic; essentially, we want to be
able to fit the itoa representation <code>UINT_64_MAX</code> into the right side of the buffer, and <code>strlen("FizzBuzz") + 1 = 9</code>
characters into the left. This allows us to write the strings <code>"Fizz\0"</code>, <code>"Buzz\0"</code>, <code>"FizzBuzz\0"</code>, or <code>"000000000"</code>
to the head of the buffer and get correct output (with no trailing garbage) after the former three cases, and ugly but
technically valid 0-padded results for the latter.
</p>

<p>
In other words, the minimum size of our buffers is \(\text{len}(\text{“FizzBuzz\\0”}) + \lceil \log_{10} (2^{64} - 1)
\rceil + 1 = 30\) bytes.
</p>

<p>
Let&rsquo;s encode that into our header, and our assembly:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #d33682;">#define</span> <span style="color: #6c71c4;">MIN_BUFFER_SIZE</span> 30
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #d33682;">%assign</span> BUFF_SIZE <span style="color: #268bd2;">30</span>
</pre>
</div>
</div>
<div id="outline-container-orgebaf028" class="outline-4">
<h4 id="orgebaf028"><span class="section-number-4">2.3.1.</span> Setup</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
With that out of the way, let&rsquo;s define our assembly function. Here&rsquo;s our header:
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #859900;">global</span> bfb_fill_buffer
<span style="color: #b58900;">bfb_fill_buffer</span>:
</pre>
</div>

<p>
The following registers are going to be used by this function:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Contains the 1st argument (pointer to output buffer) on entry, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rsi</code></td>
<td class="org-left">Contains the 2nd argument (the number to process) on entry, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r8</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r11</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
</table>

<div class="org-center">
<p>
(The x64 System V ABI defines all of these as caller-saved registers, which is good, because it&rsquo;s against our rules to
use the stack.)
</p>
</div>
</div>
</div>
<div id="outline-container-org802cb85" class="outline-4">
<h4 id="org802cb85"><span class="section-number-4">2.3.2.</span> i to a</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
The first bit of logic we need to implement is to perform an integer-to-string conversion on <code>rsi</code>, writing the result
to the rightmost portion of our output buffer.
</p>

<p>
We can simply use the classic &ldquo;modulus by ten, divide by ten, advance backwards&rdquo; algorithm to do so, with a macro loop
that unrolls at assemble-time:
</p>

<div class="org-center">
<p>
Registers used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Quotient of each division step</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Set to the constant &rsquo;10&rsquo; for base 10 and not changed</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Remainder of each division</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">initial setup
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rsi</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">move our number into the bottom half of the rdx:rax register pair
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rcx</span>, <span style="color: #268bd2;">10</span>             <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">we're doing a base 10 itoa
</span><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">repeat for every digit
</span><span style="color: #d33682;">%assign</span> i BUFF_SIZE - <span style="color: #268bd2;">2</span>
<span style="color: #d33682;">%rep</span> BUFF_SIZE - <span style="color: #268bd2;">8</span> - <span style="color: #268bd2;">1</span> - <span style="color: #268bd2;">1</span>      <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">the size of the buffer, minus strlen("FizzBuzz\0"), minus the final NULL terminator
</span>        <span style="color: #6c71c4;">xor</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #6c71c4;">rdx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">zero the top half of rdx:rax
</span>        <span style="color: #6c71c4;">div</span> <span style="color: #6c71c4;">rcx</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rax now contains the quotient, and rdx the remainder
</span>        <span style="color: #6c71c4;">add</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #2aa198;">'0'</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + i], <span style="color: #6c71c4;">dl</span>  <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">write to the buffer
</span><span style="color: #d33682;">%assign</span> i i-1
<span style="color: #d33682;">%endrep</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">cleanup
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + BUFF_SIZE - <span style="color: #268bd2;">1</span>], <span style="color: #268bd2;">0</span> <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">null-terminate the buffer</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org44855b6" class="outline-4">
<h4 id="org44855b6"><span class="section-number-4">2.3.3.</span> Euler&rsquo;s FizzBuzz</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
Next, we&rsquo;ll use the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; algorithm (\(n^4 \text{ mod } 15\)) to determine whether 3 and/or 5 are prime
factors of <code>rsi</code>:
</p>

<div class="org-center">
<p>
Registers used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rsi</code></td>
<td class="org-left">Current FizzBuzz iteration number</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Quotient of each division step</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Result of the procedure</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Magic modulus constant, re-used as a copy of the procedure result</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #6c71c4;">xor</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #6c71c4;">rdx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">zero upper half of rdx:rax
</span><span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rsi</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx:rax = rsi^1
</span><span style="color: #6c71c4;">mul</span> <span style="color: #6c71c4;">rsi</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx:rax = rsi^2
</span><span style="color: #6c71c4;">mul</span> <span style="color: #6c71c4;">rsi</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx:rax = rsi^3
</span><span style="color: #6c71c4;">mul</span> <span style="color: #6c71c4;">rsi</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx:rax = rsi^4
</span><span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rcx</span>, <span style="color: #268bd2;">15</span>
<span style="color: #6c71c4;">div</span> <span style="color: #6c71c4;">rcx</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">final remainder is now in rdx
</span><span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rcx</span>, <span style="color: #6c71c4;">rdx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">copy that result into rcx for safekeeping</span>
</pre>
</div>

<div class="org-center">
<p>
(We <code>mul</code> with <code>rsi</code> three times, instead of <code>mul rax</code> two times, because the latter will work for all 64-bit integers.)
</p>
</div>

<p>
The result of this procedure leaves the <code>rdx</code> register containing one of four possible values:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">dec</th>
<th scope="col" class="org-left">bin</th>
<th scope="col" class="org-left">IFF&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0</code></td>
<td class="org-left"><code>00000000</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is divisible by <code>3</code> and <code>5</code></td>
</tr>

<tr>
<td class="org-left"><code>1</code></td>
<td class="org-left"><code>00000001</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is coprime to <code>3</code> and <code>5</code></td>
</tr>

<tr>
<td class="org-left"><code>6</code></td>
<td class="org-left"><code>00000110</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is divisible by <code>3</code> and coprime to <code>5</code></td>
</tr>

<tr>
<td class="org-left"><code>10</code></td>
<td class="org-left"><code>00001010</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is coprime to <code>~3 and divisible by ~5</code></td>
</tr>
</tbody>
</table>

<p>
We&rsquo;ll use this to write the &ldquo;head&rdquo; of the buffer as follows:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-left" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>dl</code></th>
<th scope="col" class="org-left">byte</th>
<th scope="col" class="org-center">0</th>
<th scope="col" class="org-center">1</th>
<th scope="col" class="org-center">2</th>
<th scope="col" class="org-center">3</th>
<th scope="col" class="org-center">4</th>
<th scope="col" class="org-center">5</th>
<th scope="col" class="org-center">6</th>
<th scope="col" class="org-center">7</th>
<th scope="col" class="org-center">8</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>
</tbody>
</table>

<p>
Where &rsquo;?&rsquo; indicates we don&rsquo;t care what gets written.
</p>

<div class="org-center">
<p>
(For reference, here&rsquo;s the binary values for each of those ASCII/UTF-8 codepoints)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>NULL</code></th>
<th scope="col" class="org-left"><code>'0'</code></th>
<th scope="col" class="org-left"><code>'B'</code></th>
<th scope="col" class="org-left"><code>'F'</code></th>
<th scope="col" class="org-left"><code>'i'</code></th>
<th scope="col" class="org-left"><code>'u'</code></th>
<th scope="col" class="org-left"><code>'z'</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>00000000</code></td>
<td class="org-left"><code>00110000</code></td>
<td class="org-left"><code>01000010</code></td>
<td class="org-left"><code>01000110</code></td>
<td class="org-left"><code>01101001</code></td>
<td class="org-left"><code>01110101</code></td>
<td class="org-left"><code>01111010</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgd711518" class="outline-4">
<h4 id="orgd711518"><span class="section-number-4">2.3.4.</span> Logic Strategies</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
Now that we know the factors of <code>rsi</code>, we can use that information to compose output bytes for each of the
aforementioned positions.
</p>

<p>
In general, we can do this by creating &ldquo;conditional masks&rdquo;. Essentially, we find a way to set a register to either <code>01h</code>
or <code>00h</code> if some condition is false or true (<b>not</b> true or false), respectively, and then decrement that register. This
leaves the register with the value <code>FFFFFFFFFFFFFFFFh</code> if the condition was true, and <code>0000000000000000h</code> if the
condition was false. This register can now be used as a <i>mask</i> for other registers &#x2013; <code>and</code>​ing with it leaves the
destination unchanged if the initial condition was true, and zeroes it if it was false.
</p>

<p>
In cases where there are only two possible options for what we&rsquo;ll want to write at a given byte offset (e.g. byte 2, or
byte 8), we can use the following pseudocode procedure to set a register based on a condition:
</p>

<pre class="example" id="org490517e">
let is_a_or_b = 0 or 1, depending
mask = is_a_or_b - 1

let result = A &amp; mask
mask = not mask, toggling it
mask &amp;= B
result |= mask
</pre>

<p>
which clobbers <code>mask</code> and sets <code>result</code> to <code>A</code> if <code>is_a_or_b</code> was <code>0</code>, or <code>B</code> if it was <code>1</code>.
</p>

<p>
In cases where there are three possible values for what we&rsquo;ll want to write at a given byte offset (e.g. byte 0 or byte
1), we can extend this procedure to compose our result by means of integer addition and <i>two</i> masks; one that&rsquo;s <code>0</code> or
<code>1</code> if it&rsquo;s option 1 or option 2 (and whatever if it&rsquo;s option 3), and another that&rsquo;s <code>1</code> if it&rsquo;s option C and <code>0</code>
otherwise (<b>note that that&rsquo;s reversed!</b>).
</p>

<p>
In pseudocode:
</p>

<pre class="example" id="org27be6c4">
let is_a_or_b = 0 or 1, depending (value doesn't matter if it's c)
mask = is_a_or_b - 1

let result = (the difference between A and C) &amp; mask
mask = not mask, toggling it
mask &amp;= (the difference between B and C)
result |= mask

let is_not_c_or_c = 0 or 1, depending
let new_mask = is_not_c_or_c - 1

result &amp;= new_mask, zeroing it if it was option c
result += C
</pre>

<p>
which clobbers <code>mask</code> and <code>new_mask</code> (may or may not be the same register, depending on where our results start
appearing in our implemented procedure) and sets <code>result</code> to <code>A</code> if <code>is_a_or_b</code> was <code>0</code> and <code>is_not_c_or_c</code> was <code>0</code>, to
<code>B</code> if <code>is_a_or_b</code> was <code>0</code> and <code>is_not_c_or_c</code> was <code>0</code>, or to <code>C</code> if <code>is_not_c_or_c</code> was <code>1</code>.
</p>

<p>
With only some slight modifications for conciseness (we don&rsquo;t want to recalculate anything we don&rsquo;t have to, do we?),
these two procedures form the majority of the following code. The rest is discrimination logic (actually setting
<code>is_a_or_b</code> depending on some factor), actually writing bytes to the output buffer, and some funny instruction
count-optimizations based on the &ldquo;bits set (as in 1) or unset (as in 0)&rdquo; set (as in the collection in math) relationship
between different characters.
</p>
</div>
</div>
<div id="outline-container-org4905f12" class="outline-4">
<h4 id="org4905f12"><span class="section-number-4">2.3.5.</span> &ldquo;Coprime to Both or Not&rdquo;-Specific Bytes</h4>
<div class="outline-text-4" id="text-2-3-5">
<p>
For bytes 2, 3, 6, 7, and 8; we only need to discriminate depending on if <code>rdx</code> is equal to <code>1</code>, writing a <code>'0'</code> if so;
and either a <code>'z'</code> (bytes 2, 3, 6 and 7) or <code>NULL</code> (byte 8) if not, so we can use the simple two-option procedure (with
some slight modification, because we&rsquo;re setting two different result registers).
</p>

<div class="org-center">
<p>
Registers used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Immutable copy of the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; procedure result</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Value to write to buffer offsets 2, 3, 6 and 7</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Value to write to buffer offset 8</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">determine if rdx (rcx) is 1 or not
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #6c71c4;">rcx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">restore rdx
</span>        <span style="color: #6c71c4;">dec</span> <span style="color: #6c71c4;">edx</span>
        <span style="color: #6c71c4;">neg</span> <span style="color: #6c71c4;">rdx</span>
        <span style="color: #6c71c4;">shr</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #268bd2;">63</span>             <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx is now 00h if it was 1, and 01h otherwise
</span>        <span style="color: #6c71c4;">dec</span> <span style="color: #6c71c4;">rdx</span>
        <span style="color: #6c71c4;">not</span> <span style="color: #6c71c4;">rdx</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx is now 00h if it was 1, and FFFFFFFFFFFFFFFFh otherwise
</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">set rax to '0' if rdx is 1, and NULL otherwise
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rdx</span>
        <span style="color: #6c71c4;">not</span> <span style="color: #6c71c4;">rax</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #2aa198;">'0'</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">set rdx to '0' if it was 1, and 'z' otherwise
</span>        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #2aa198;">'z'</span> - <span style="color: #2aa198;">'0'</span>
        <span style="color: #6c71c4;">add</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #2aa198;">'0'</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">write our bytes
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">2</span>], <span style="color: #6c71c4;">dl</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">3</span>], <span style="color: #6c71c4;">dl</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">6</span>], <span style="color: #6c71c4;">dl</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">7</span>], <span style="color: #6c71c4;">dl</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">8</span>], <span style="color: #6c71c4;">al</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org45e721f" class="outline-4">
<h4 id="org45e721f"><span class="section-number-4">2.3.6.</span> Byte 4</h4>
<div class="outline-text-4" id="text-2-3-6">
<p>
For byte 4, the only byte where we need to distinguish based on the intended output&rsquo;s <i>length,</i> we can use bit position
1 in <code>rdx</code> to distinguish <code>6</code> and <code>10</code> from <code>0</code> and <code>1</code> (it&rsquo;s set in the former and unset in the latter), and bit
position 0 (only set in the former, obviously) to distinguish <code>1</code> from <code>0</code>.
</p>

<p>
We are conveniently aided by the facts that, in terms of set bits, <code>'B'</code> and <code>'0'</code> are disjoint; and that <code>NULL</code> is
zeroed. This enables us to use a simplified form of the three-option procedure.
</p>

<div class="org-center">
<p>
Registers:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Copy of the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; procedure result, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Scratch register, used to compose conditional masks</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Value to write to buffer offset 4</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm">        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #6c71c4;">rcx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">restore rdx
</span>        <span style="color: #6c71c4;">xor</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rax</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">zero rax, we'll compose our result in here
</span><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">set up as though this weren't 6 or 10
</span>        <span style="color: #6c71c4;">dec</span> <span style="color: #6c71c4;">rdx</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx is now 00h if it was 1, and FFFFFFFFFFFFFFFFh if it was 0
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #2aa198;">'B'</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rdx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rax is now 'B' if rdx was 0 and 00h if rdx was 1
</span>        <span style="color: #6c71c4;">not</span> <span style="color: #6c71c4;">rdx</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #2aa198;">'0'</span>
        <span style="color: #6c71c4;">or</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rdx</span>             <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rax is now '0' if rdx was 1 and unchanged if rdx was 0
</span><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">"is it 0 or 1" mask
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #6c71c4;">rcx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">restore rdx
</span>        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #268bd2;">00000010b</span>
        <span style="color: #6c71c4;">sub</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #268bd2;">00000010b</span>      <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx is now 00h if it was &gt; 1, else FFFFFFFFFFFFFFFFh
</span>        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rdx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rax is now 00h (NULL) if rdx was &gt; 1
</span><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">write our byte
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">4</span>], <span style="color: #6c71c4;">al</span>

</pre>
</div>
</div>
</div>
<div id="outline-container-org39d4c13" class="outline-4">
<h4 id="org39d4c13"><span class="section-number-4">2.3.7.</span> &ldquo;Fizz vs Buzz vs <code>itoa</code>&rdquo;</h4>
<div class="outline-text-4" id="text-2-3-7">
<p>
Finally, for bytes 0, 1 and 5, we need to discriminate based on whether <code>rdx</code> is equal to <code>1</code>, or if it&rsquo;s equal to <code>10</code>,
or if it&rsquo;s equal to <code>0</code> or <code>6</code>.
</p>

<p>
To distinguish <code>0</code> and <code>6</code> from <code>1</code> and <code>10</code>, we can decrement <code>rdx</code> and check if bit 2 is <code>1</code>. If it is, it&rsquo;s <code>0</code> or
<code>6</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>dl</code></th>
<th scope="col" class="org-left"><code>dl - 1</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>00000000</code></td>
<td class="org-left"><code>11111111</code></td>
</tr>

<tr>
<td class="org-left"><code>00000001</code></td>
<td class="org-left"><code>00000000</code></td>
</tr>

<tr>
<td class="org-left"><code>00000110</code></td>
<td class="org-left"><code>00000101</code></td>
</tr>

<tr>
<td class="org-left"><code>00001010</code></td>
<td class="org-left"><code>00001001</code></td>
</tr>
</tbody>
</table>

<p>
To distinguish <code>1</code>, we only have to look at the 0th bit of <code>rdx - 1</code>: it&rsquo;ll be set if it was <code>0</code>, <code>6</code> or <code>10</code>, and unset
if it was <code>1</code>.
</p>

<p>
From these two bit positions, we can calculate the proper character value. Conveniently, we can turn <code>'B'</code> into <code>'F'</code> by
setting the very same bit position, and the bits of <code>'0'</code> are mutually exclusive with those of either. <i>Unfortunately,</i>
&rsquo;i&rsquo; and &rsquo;u&rsquo; are overlapping non-subsets. &rsquo;u&rsquo; <i>is</i> a superset of &rsquo;0&rsquo;, though.
</p>

<p>
This logic is pretty involved, since we have three completely different results to compose and three possible options;
fortunately, since these are the last bytes and we don&rsquo;t need to restore <code>rdx</code> anymore, we can afford to clobber <code>rcx</code>
for another non-REX scratch register.
</p>

<div class="org-center">
<p>
Registers:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Copy of the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; procedure result,</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">later re-used as the bit-unset mask for both-coprime results</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Scratch, used to compose conditional masks</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Value to write to buffer offset 0</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r8</code></td>
<td class="org-left">Value to write to buffer offset 1</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r11</code></td>
<td class="org-left">Value to write to buffer offset 5</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">is it 0 or 6? or is it something else?
</span>        <span style="color: #6c71c4;">dec</span> <span style="color: #6c71c4;">rcx</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rcx</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #268bd2;">00000100b</span>      <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rax now contains 04h if rcx was 0 or 6, and 00h if it was 1 or 10
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #6c71c4;">rax</span>
        <span style="color: #6c71c4;">or</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #2aa198;">'B'</span>             <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rax now contains 'F' if rcx was 0 or 6, and 'B' if it was 1 or 10
</span>
        <span style="color: #6c71c4;">shr</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #268bd2;">2</span>
        <span style="color: #6c71c4;">dec</span> <span style="color: #6c71c4;">rdx</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rdx now contains 00h if rcx was 0 or 6, and FFFFFFFFFFFFFFFFh if it was 1 or 10
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">r8</span>, <span style="color: #2aa198;">'u'</span> - <span style="color: #2aa198;">'0'</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">r8</span>, <span style="color: #6c71c4;">rdx</span>             <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">r8 now contains 'u' - '0' if rcx was 1 or 10, and 00h if it was 0 or 6
</span>        <span style="color: #6c71c4;">not</span> <span style="color: #6c71c4;">rdx</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">r11</span>, <span style="color: #6c71c4;">rdx</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #2aa198;">'i'</span> - <span style="color: #2aa198;">'0'</span>
        <span style="color: #6c71c4;">or</span> <span style="color: #6c71c4;">r8</span>, <span style="color: #6c71c4;">rdx</span>              <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">r8 now contains 'i' - '0' if rcx was 0 or 6, and is unchanged if it was 1 or 10
</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">r11</span>, <span style="color: #2aa198;">'u'</span>
        <span style="color: #6c71c4;">or</span> <span style="color: #6c71c4;">r11</span>, <span style="color: #2aa198;">'0'</span>              <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">r11 now contains 'u' if rcx was 0 or 6, and '0' if it was 1 or 10
</span><span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">write byte 5
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">5</span>], <span style="color: #6c71c4;">r11b</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">but was it 1 all along?
</span>        <span style="color: #6c71c4;">not</span> <span style="color: #6c71c4;">rcx</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rcx</span>, <span style="color: #268bd2;">00000001b</span>      <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rcx now contains 01h if it was 1, and 00h otherwise
</span>        <span style="color: #6c71c4;">dec</span> <span style="color: #6c71c4;">rcx</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rcx now contains 00h if our initial rcx value was 1, and FFFFFFFFFFFFFFFFh otherwise
</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">r8</span>, <span style="color: #6c71c4;">rcx</span>
        <span style="color: #6c71c4;">add</span> <span style="color: #6c71c4;">r8</span>, <span style="color: #2aa198;">'0'</span>             <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">r8 now contains '0' if our initial rcx value was 1, 'u' if it was 10, and 'i' if it was 0 or 6
</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">write byte 1
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span> + <span style="color: #268bd2;">1</span>], <span style="color: #6c71c4;">r8b</span>

<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">wrap up "was it 1 all along?"
</span>        <span style="color: #6c71c4;">not</span> <span style="color: #6c71c4;">rcx</span>                 <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">rcx now contains FFFFFFFFFFFFFFFFh if our initial rcx value was 1, and 00h otherwise
</span>
        <span style="color: #6c71c4;">mov</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #6c71c4;">rcx</span>
        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rdx</span>, <span style="color: #2aa198;">'0'</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">our *set* mask
</span>        <span style="color: #6c71c4;">and</span> <span style="color: #6c71c4;">rcx</span>, <span style="color: #6c71c4;">rax</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">our *unset* mask
</span>

        <span style="color: #6c71c4;">xor</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rcx</span>            <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">sets rax to 0 if our initial rcx value was 1, otherwise leaves it unchanged
</span>        <span style="color: #6c71c4;">or</span> <span style="color: #6c71c4;">rax</span>, <span style="color: #6c71c4;">rdx</span>             <span style="color: #93a1a1; font-style: italic;">; </span><span style="color: #93a1a1; font-style: italic;">sets rax to '0' if our initial rcx value was 1, otherwise leaves it unchanged
</span>
<span style="color: #93a1a1; font-style: italic;">;; </span><span style="color: #93a1a1; font-style: italic;">write byte 0
</span>        <span style="color: #6c71c4;">mov</span> <span style="color: #268bd2;">byte</span> [<span style="color: #6c71c4;">rdi</span>], <span style="color: #6c71c4;">al</span>
</pre>
</div>

<p>
And with that, we&rsquo;re all done!
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #6c71c4;">ret</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf75023c" class="outline-2">
<h2 id="orgf75023c"><span class="section-number-2">3.</span> Building</h2>
<div class="outline-text-2" id="text-3">
<p>
This project requires make, YASM, gcc, and mkdir for building, and targets only systems which use the System V ABI.
</p>

<p>
To build, just clone the repo, navigate to the root directory, and run <code>make</code>. The binary will be located at
<code>build/branchless_fizzbuzz</code>.
</p>

<p>
To remove all build products from the build directory, run <code>make clean</code>. To remove all build products <i>and</i> the binary
from the build directory, run <code>make pristine</code>.
</p>
</div>
</div>
<div id="outline-container-orgf9cc34a" class="outline-2">
<h2 id="orgf9cc34a"><span class="section-number-2">4.</span> Potential Further Improvements</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li>Correct the logic which leads to a FPE with sufficently large values of <code>i</code> (​<code>rsi</code>​)</li>
<li>Have the assembly portion return a pointer the beginning of the string, instead of just <i>assuming</i> it&rsquo;s the same as
the start of the buffer. Would allow us to elide all those leading 0s.</li>
<li>Replace the loop in the C driver with a <code>%rep</code> loop in the assembly portion of the project. If taken with #1, would
probably involve passing a pair of buffers: one to write data to, and another to write pointers to the starts of each
string. First buffer should probably be 32-byte aligned.</li>
<li>Get better at assembly and find better and arcane-er ways to implement everything.</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-09-13 Sat 20:03</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
