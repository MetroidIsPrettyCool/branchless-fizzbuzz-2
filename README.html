<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-30 Tue 19:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>No-Conditional Logic FizzBuzz in C + x64 assembly</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<style> pre.src { background-color: black; color: white; }</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">No-Conditional Logic FizzBuzz in C + x64 assembly</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgfdd8c4e">1. Introduction</a></li>
<li><a href="#org780b61a">2. Implementation</a>
<ul>
<li><a href="#orgac1aebc">2.1. The Rules</a></li>
<li><a href="#orgf88895a">2.2. Project Structure</a></li>
<li><a href="#orgf1c41c5">2.3. The Driver</a></li>
<li><a href="#org4ede45d">2.4. <code>bfb_fill_buffer</code></a>
<ul>
<li><a href="#orgf44ee72">2.4.1. Parameters</a></li>
<li><a href="#org33ec9c6">2.4.2. Buffer Size</a></li>
<li><a href="#orga86ebe8">2.4.3. Setup</a></li>
<li><a href="#orgaa2b1df">2.4.4. i to a</a></li>
<li><a href="#orgcccc3f6">2.4.5. Euler&rsquo;s FizzBuzz</a></li>
<li><a href="#org56f7c5e">2.4.6. Logic Strategies</a></li>
<li><a href="#org5e5a2ac">2.4.7. &ldquo;Coprime to Both or Not&rdquo;-Specific Bytes</a></li>
<li><a href="#orgfc03837">2.4.8. Byte 4</a></li>
<li><a href="#org240b6ee">2.4.9. &ldquo;Fizz vs Buzz vs <code>itoa</code>&rdquo;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org505df75">3. Building</a></li>
<li><a href="#org1bad688">4. Potential Further Improvements</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgfdd8c4e" class="outline-2">
<h2 id="orgfdd8c4e"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Okay, so a couple years back I was reading this great blog post titled &ldquo;Euler&rsquo;s Fizzbuzz&rdquo; (you can find it here:
<a href="http://philcrissman.net/posts/eulers-fizzbuzz/">http://philcrissman.net/posts/eulers-fizzbuzz/</a>, read it!), which describes a really interesting technique for
differentiating numbers by their prime factors with only simple integer arithmetic. One little piece of that post, right
at the start, has been stuck in the back of my mind ever since I first read it:
</p>

<blockquote>
<p>
It is possible to write a function which uses no conditional logic at all, but which uses math to separate integers into
4 possible categories:
</p>

<ol class="org-ol">
<li>Those which have 3 as a factor, but not 5</li>
<li>Those which have 5 as a factor, but not 3</li>
<li>Those which have both 3 and 5 as a factor</li>
<li>Those which have neither 3 nor 5 as factors</li>
</ol>
</blockquote>

<p>
&ldquo;No conditional logic&rdquo;, huh? Isn&rsquo;t that an interesting idea.
</p>

<p>
Well, it follows from that, that if we can differentiate numbers based on their prime factors, we can use a lookup table
to determine what to output for that number (&ldquo;Fizz&rdquo;, &ldquo;Buzz&rdquo;, &ldquo;FizzBuzz&rdquo;, or the <code>itoa</code> representation of the input); and
it follows from <i>that</i> that, since there&rsquo;s an equivalent implementation with logic gates for every lookup table (and
vice versa), we can implement the <b>whole function</b> without conditional logic. No branches, no tests, and no
comparisons. We don&rsquo;t need &rsquo;em!
</p>

<p>
I thought it&rsquo;d be fun to give that a try.
</p>
</div>
</div>
<div id="outline-container-org780b61a" class="outline-2">
<h2 id="org780b61a"><span class="section-number-2">2.</span> Implementation</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgac1aebc" class="outline-3">
<h3 id="orgac1aebc"><span class="section-number-3">2.1.</span> The Rules</h3>
<div class="outline-text-3" id="text-2-1">
<p>
To be more specific than just &ldquo;no conditional logic&rdquo;, let&rsquo;s define a rule set for ourselves. We&rsquo;re not going to do any
of the following in our implementation:
</p>

<ul class="org-ul">
<li><code>jcc</code> (or family),</li>
<li><code>jmp</code> (or family),</li>
<li><code>rep</code> (or family),</li>
<li><code>call</code> (or family),</li>
<li><code>syscall</code>, <code>int</code>, or any other kind of trap (conditional or otherwise),</li>
<li>anything <i>else</i> that mutates <code>rip</code> in any way, besides advancing it to the next instruction;</li>
<li><code>mov</code>​es from memory to anywhere else;</li>
<li>perform indirections of any form other than <code>[rdi] + disp64</code> (implicit or otherwise &#x2013; that means <code>push</code> and <code>movs</code>
and so forth),</li>
<li>mutate <code>rdi</code> at any point, for any reason</li>
</ul>

<p>
Because I/O is always gonna involve breaking at least <i>one</i> of these rules, we need an &ldquo;impure&rdquo; piece of driver code to
interface with our FizzBuzz function and print the results.
</p>
</div>
</div>
<div id="outline-container-orgf88895a" class="outline-3">
<h3 id="orgf88895a"><span class="section-number-3">2.2.</span> Project Structure</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This project is split into two source files. The driver is written in C, and implements the outer loop and printing
logic; and our FizzBuzz function is written in x64 assembly, to avoid the compiler doing anything against the rules
behind our backs, and implements the following pseudocode logic:
</p>

<pre class="example" id="org76f24bc">
if n % 3 == 0 &amp;&amp; n % 5 != 0:
  return "Fizz"
if n % 3 != 0 &amp;&amp; n % 5 == 0:
  return "Buzz"
if n % 3 == 0 &amp;&amp; n % 5 == 0:
  return "FizzBuzz"
if n % 3 != 0 &amp;&amp; n % 5 != 0:
  return itoa(n)
</pre>
</div>
</div>
<div id="outline-container-orgf1c41c5" class="outline-3">
<h3 id="orgf1c41c5"><span class="section-number-3">2.3.</span> The Driver</h3>
<div class="outline-text-3" id="text-2-3">
<p>
The implementation of the driver is pretty simple. We import some standard headers:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #e5786d;">#include</span> <span style="color: #95e454;">&lt;stdio.h&gt;</span>
<span style="color: #e5786d;">#include</span> <span style="color: #95e454;">&lt;stdlib.h&gt;</span>

<span style="color: #e5786d;">#include</span> <span style="color: #95e454;">&lt;stdint.h&gt;</span>
</pre>
</div>

<p>
and then our project-specific header (which we&rsquo;ll cover in a sec.), to link against the assembly source:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #e5786d;">#include</span> <span style="color: #95e454;">"branchless_fizzbuzz.h"</span>
</pre>
</div>

<p>
and then we just allocate a character buffer for our assembly function, call it in a loop, and print each result:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">main</span>(<span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">argc</span>, <span style="color: #92a65e; font-weight: bold;">char</span>* <span style="color: #cae682;">argv</span>[]) {
    <span style="color: #92a65e; font-weight: bold;">char</span> <span style="color: #cae682;">buffer</span>[MIN_BUFFER_SIZE] = {0};

    <span style="color: #8ac6f2; font-weight: bold;">for</span> (<span style="color: #92a65e; font-weight: bold;">uint64_t</span> <span style="color: #cae682;">i</span> = 1; i != 1000; i++) {
        bfb_fill_buffer(buffer, i);

        puts(buffer);
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org4ede45d" class="outline-3">
<h3 id="org4ede45d"><span class="section-number-3">2.4.</span> <code>bfb_fill_buffer</code></h3>
<div class="outline-text-3" id="text-2-4">
<p>
Implementing <code>bfb_fill_buffer</code> is, of course, significantly more involved.
</p>
</div>
<div id="outline-container-orgf44ee72" class="outline-4">
<h4 id="orgf44ee72"><span class="section-number-4">2.4.1.</span> Parameters</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
First, let&rsquo;s define our parameters. As you can see from the driver code, we need two things: a buffer to write to, and
the iteration number to process. Both are 64-bit; the former a pointer, the latter simply an unsigned integer.
</p>

<p>
Let&rsquo;s define that in our header file:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #e5786d;">#include</span> <span style="color: #95e454;">&lt;stdint.h&gt;</span>   <span style="color: #99968b;">// </span><span style="color: #99968b;">ensure uint64_t is defined
</span>
<span style="color: #92a65e; font-weight: bold;">void</span> <span style="color: #cae682;">bfb_fill_buffer</span>(<span style="color: #92a65e; font-weight: bold;">char</span>*, <span style="color: #92a65e; font-weight: bold;">uint64_t</span>);
</pre>
</div>
</div>
</div>
<div id="outline-container-org33ec9c6" class="outline-4">
<h4 id="org33ec9c6"><span class="section-number-4">2.4.2.</span> Buffer Size</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
Second, let&rsquo;s hardcode the size of the output buffer. (Without conditional logic, we have no means to terminate loops &#x2013;
everything is gonna have to be unrolled.)
</p>

<p>
The minimum size is constrained to \(\text{len}(\text{“FizzBuzz\\0”}) + \lceil \log_{10} (2^{64} - 1) \rceil + 1 = 30\)
bytes, as we want to be able to fit the <code>itoa</code> representation of <code>UINT_64_MAX</code> into the right side of the buffer and
<code>strlen("FizzBuzz") + 1 = 9</code> characters into the left.
</p>

<p>
This will allow us to write the strings <code>"Fizz\0"</code>, <code>"Buzz\0"</code>, <code>"FizzBuzz\0"</code>, or <code>"000000000"</code> to the head of the
buffer and get correct output (with no trailing garbage) for the former three cases, and ugly but technically valid
0-padded results for the latter.
</p>

<p>
Let&rsquo;s encode this into our header file and into our assembly source:
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #e5786d;">#define</span> <span style="color: #cae682;">MIN_BUFFER_SIZE</span> 30
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #e5786d;">%assign</span> BUFF_SIZE <span style="color: #e5786d;">30</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga86ebe8" class="outline-4">
<h4 id="orga86ebe8"><span class="section-number-4">2.4.3.</span> Setup</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
With that out of the way, let&rsquo;s actually start writing our assembly function. Here&rsquo;s our header:
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #8ac6f2; font-weight: bold;">global</span> bfb_fill_buffer
<span style="color: #cae682;">bfb_fill_buffer</span>:
</pre>
</div>

<p>
and here&rsquo;s the registers we&rsquo;re gonna use:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Contains the 1st argument (pointer to output buffer) on entry, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rsi</code></td>
<td class="org-left">Contains the 2nd argument (the number to process) on entry, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r8</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r11</code></td>
<td class="org-left">Miscellaneous</td>
</tr>
</tbody>
</table>

<div class="org-center">
<p>
(The x64 System V ABI defines all of these as caller-saved registers, which is good, because it&rsquo;s against our rules to
use the stack.)
</p>
</div>
</div>
</div>
<div id="outline-container-orgaa2b1df" class="outline-4">
<h4 id="orgaa2b1df"><span class="section-number-4">2.4.4.</span> i to a</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
The first bit of logic we need to implement is to perform an integer-to-string conversion on <code>rsi</code>, writing the result
to the rightmost portion of our output buffer.
</p>

<p>
We can simply use the classic &ldquo;modulus by ten, divide by ten, advance backwards&rdquo; algorithm to do so, with a macro loop
that unrolls at assemble-time:
</p>

<div class="org-center">
<p>
Registers used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Quotient of each division step</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Set to the constant &rsquo;10&rsquo; for base 10 and not changed</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Remainder of each division</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #99968b;">;; </span><span style="color: #99968b;">initial setup
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rsi</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">move our number into the bottom half of the rdx:rax register pair
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rcx</span>, <span style="color: #e5786d;">10</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">we're doing a base 10 itoa
</span><span style="color: #99968b;">;; </span><span style="color: #99968b;">repeat for every digit
</span><span style="color: #e5786d;">%assign</span> i BUFF_SIZE - <span style="color: #e5786d;">2</span>
<span style="color: #e5786d;">%rep</span> BUFF_SIZE - <span style="color: #e5786d;">8</span> - <span style="color: #e5786d;">1</span> - <span style="color: #e5786d;">1</span>      <span style="color: #99968b;">; </span><span style="color: #99968b;">the size of the buffer, minus strlen("FizzBuzz\0"), minus the final NULL terminator
</span>        <span style="color: #e5786d;">xor</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rdx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">zero the top half of rdx:rax
</span>        <span style="color: #e5786d;">div</span> <span style="color: #cae682;">rcx</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rax now contains the quotient, and rdx the remainder
</span>        <span style="color: #e5786d;">add</span> <span style="color: #cae682;">rdx</span>, <span style="color: #95e454;">'0'</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + i], <span style="color: #cae682;">dl</span>  <span style="color: #99968b;">; </span><span style="color: #99968b;">write to the buffer
</span><span style="color: #e5786d;">%assign</span> i i-1
<span style="color: #e5786d;">%endrep</span>
<span style="color: #99968b;">;; </span><span style="color: #99968b;">cleanup
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + BUFF_SIZE - <span style="color: #e5786d;">1</span>], <span style="color: #e5786d;">0</span> <span style="color: #99968b;">; </span><span style="color: #99968b;">null-terminate the buffer</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcccc3f6" class="outline-4">
<h4 id="orgcccc3f6"><span class="section-number-4">2.4.5.</span> Euler&rsquo;s FizzBuzz</h4>
<div class="outline-text-4" id="text-2-4-5">
<p>
Next, we&rsquo;ll use the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; algorithm (\(n^4 \text{ mod } 15\)) to determine whether 3 and/or 5 are prime
factors of <code>rsi</code>. Since we want to handle all possible 64-bit integers as input, we&rsquo;ll take advantage of the fact that
<a href="https://en.wikipedia.org/wiki/Modular_exponentiation">modular exponentiation</a> allows us to reduce <code>x</code> at any point during the exponentiation, and take the modulus of <code>rsi</code>
right before we exponentiate it, preventing any overflows or <code>#DE</code> exceptions. (The maximum possible result after that
modulus &#x2013; 15 &#x2013; raised to the fourth power is only 50625, nowhere <i>near</i> <code>UINT64_MAX</code>, so we don&rsquo;t have to perform any
more expensive division operations until the very end.)
</p>

<div class="org-center">
<p>
Registers used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rsi</code></td>
<td class="org-left">Current FizzBuzz iteration number</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Quotient of each division step</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Result of the procedure</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Magic modulus constant, re-used as a copy of the procedure result</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rcx</span>, <span style="color: #e5786d;">15</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">magic constant, see aforementioned blog post
</span><span style="color: #e5786d;">xor</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rdx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">zero upper half of rdx:rax
</span><span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rsi</span>
<span style="color: #e5786d;">div</span> <span style="color: #cae682;">rcx</span>
<span style="color: #e5786d;">xchg</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rax</span>
<span style="color: #e5786d;">xor</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rdx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx:rax = rsi mod 15
</span>
<span style="color: #e5786d;">mul</span> <span style="color: #cae682;">rax</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx:rax = (rsi mod 15)^2
</span><span style="color: #e5786d;">mul</span> <span style="color: #cae682;">rax</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx:rax = (rsi mod 15)^4
</span><span style="color: #e5786d;">div</span> <span style="color: #cae682;">rcx</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx = (rsi^4) mod 15
</span><span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rcx</span>, <span style="color: #cae682;">rdx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">copy the result into rcx for safekeeping</span>
</pre>
</div>

<p>
The result of this procedure leaves the <code>rdx</code> register containing one of four possible values:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>

<colgroup>
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">dec</th>
<th scope="col" class="org-left">bin</th>
<th scope="col" class="org-left">IFF&#x2026;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>0</code></td>
<td class="org-left"><code>00000000</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is divisible by <code>3</code> and <code>5</code></td>
</tr>

<tr>
<td class="org-left"><code>1</code></td>
<td class="org-left"><code>00000001</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is coprime to <code>3</code> and <code>5</code></td>
</tr>

<tr>
<td class="org-left"><code>6</code></td>
<td class="org-left"><code>00000110</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is divisible by <code>3</code> and coprime to <code>5</code></td>
</tr>

<tr>
<td class="org-left"><code>10</code></td>
<td class="org-left"><code>00001010</code></td>
<td class="org-left">&#x2026;​<code>rsi</code> is coprime to <code>3</code> and divisible by <code>5</code></td>
</tr>
</tbody>
</table>

<p>
We&rsquo;ll use this to write the &ldquo;head&rdquo; of the buffer as follows:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-left" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>dl</code></th>
<th scope="col" class="org-left">byte</th>
<th scope="col" class="org-center">0</th>
<th scope="col" class="org-center">1</th>
<th scope="col" class="org-center">2</th>
<th scope="col" class="org-center">3</th>
<th scope="col" class="org-center">4</th>
<th scope="col" class="org-center">5</th>
<th scope="col" class="org-center">6</th>
<th scope="col" class="org-center">7</th>
<th scope="col" class="org-center">8</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
<td class="org-center"><code>'0'</code></td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>
</tbody>
</table>

<p>
Where &rsquo;?&rsquo; indicates we don&rsquo;t care what gets written.
</p>

<div class="org-center">
<p>
(For reference, here&rsquo;s the binary values for each of those ASCII/UTF-8 codepoints)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>NULL</code></th>
<th scope="col" class="org-left"><code>'0'</code></th>
<th scope="col" class="org-left"><code>'B'</code></th>
<th scope="col" class="org-left"><code>'F'</code></th>
<th scope="col" class="org-left"><code>'i'</code></th>
<th scope="col" class="org-left"><code>'u'</code></th>
<th scope="col" class="org-left"><code>'z'</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>00000000</code></td>
<td class="org-left"><code>00110000</code></td>
<td class="org-left"><code>01000010</code></td>
<td class="org-left"><code>01000110</code></td>
<td class="org-left"><code>01101001</code></td>
<td class="org-left"><code>01110101</code></td>
<td class="org-left"><code>01111010</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org56f7c5e" class="outline-4">
<h4 id="org56f7c5e"><span class="section-number-4">2.4.6.</span> Logic Strategies</h4>
<div class="outline-text-4" id="text-2-4-6">
<p>
Now that we know the factors of <code>rsi</code>, we can use that information to compose output bytes for each of the
aforementioned positions.
</p>

<p>
In general, we can do this by creating &ldquo;conditional masks&rdquo;. Essentially, we find a way to set a register to either <code>01h</code>
or <code>00h</code> if some condition is false or true (<b>not</b> true or false), respectively, and then decrement that register. This
leaves the register with the value <code>FFFFFFFFFFFFFFFFh</code> if the condition was true, and <code>0000000000000000h</code> if the
condition was false. This register can now be used as a <i>mask</i> for other registers &#x2013; <code>and</code>​ing with it leaves the
destination unchanged if the initial condition was true, and zeroes it if it was false.
</p>

<p>
In cases where there are only two possible options for what we&rsquo;ll want to write at a given byte offset (e.g. byte 2, or
byte 8), we can use the following pseudocode procedure to set a register based on a condition:
</p>

<pre class="example" id="org78aa80a">
let is_a_or_b = 0 or 1, depending
mask = is_a_or_b - 1

let result = A &amp; mask
mask = not mask, toggling it
mask &amp;= B
result |= mask
</pre>

<p>
which clobbers <code>mask</code> and sets <code>result</code> to <code>A</code> if <code>is_a_or_b</code> was <code>0</code>, or <code>B</code> if it was <code>1</code>.
</p>

<p>
In cases where there are three possible values for what we&rsquo;ll want to write at a given byte offset (e.g. byte 0 or byte
1), we can extend this procedure to compose our result by means of integer addition and <i>two</i> masks; one that&rsquo;s <code>0</code> or
<code>1</code> if it&rsquo;s option 1 or option 2 (and whatever if it&rsquo;s option 3), and another that&rsquo;s <code>1</code> if it&rsquo;s option C and <code>0</code>
otherwise (<b>note that that&rsquo;s reversed!</b>).
</p>

<p>
In pseudocode:
</p>

<pre class="example" id="orgb2a893a">
let is_a_or_b = 0 or 1, depending (value doesn't matter if it's c)
mask = is_a_or_b - 1

let result = (the difference between A and C) &amp; mask
mask = not mask, toggling it
mask &amp;= (the difference between B and C)
result |= mask

let is_not_c_or_c = 0 or 1, depending
let new_mask = is_not_c_or_c - 1

result &amp;= new_mask, zeroing it if it was option c
result += C
</pre>

<p>
which clobbers <code>mask</code> and <code>new_mask</code> (may or may not be the same register, depending on where our results start
appearing in our implemented procedure) and sets <code>result</code> to <code>A</code> if <code>is_a_or_b</code> was <code>0</code> and <code>is_not_c_or_c</code> was <code>0</code>, to
<code>B</code> if <code>is_a_or_b</code> was <code>0</code> and <code>is_not_c_or_c</code> was <code>0</code>, or to <code>C</code> if <code>is_not_c_or_c</code> was <code>1</code>.
</p>

<p>
With only some slight modifications for conciseness (we don&rsquo;t want to recalculate anything we don&rsquo;t have to, do we?),
these two procedures form the majority of the following code. The rest is discrimination logic (actually setting
<code>is_a_or_b</code> depending on some factor), actually writing bytes to the output buffer, and some funny instruction
count-optimizations based on the &ldquo;bits set (as in 1) or unset (as in 0)&rdquo; set (as in the collection in math) relationship
between different characters.
</p>
</div>
</div>
<div id="outline-container-org5e5a2ac" class="outline-4">
<h4 id="org5e5a2ac"><span class="section-number-4">2.4.7.</span> &ldquo;Coprime to Both or Not&rdquo;-Specific Bytes</h4>
<div class="outline-text-4" id="text-2-4-7">
<p>
For bytes 2, 3, 6, 7, and 8; we only need to discriminate depending on if <code>rdx</code> is equal to <code>1</code>, writing a <code>'0'</code> if so;
and either a <code>'z'</code> (bytes 2, 3, 6 and 7) or <code>NULL</code> (byte 8) if not, so we can use the simple two-option procedure (with
some slight modification, because we&rsquo;re setting two different result registers).
</p>

<div class="org-center">
<p>
Registers used:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Immutable copy of the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; procedure result</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Value to write to buffer offsets 2, 3, 6 and 7</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Value to write to buffer offset 8</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #99968b;">;; </span><span style="color: #99968b;">determine if rdx (rcx) is 1 or not
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rcx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">restore rdx
</span>        <span style="color: #e5786d;">dec</span> <span style="color: #cae682;">edx</span>
        <span style="color: #e5786d;">neg</span> <span style="color: #cae682;">rdx</span>
        <span style="color: #e5786d;">shr</span> <span style="color: #cae682;">rdx</span>, <span style="color: #e5786d;">63</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx is now 00h if it was 1, and 01h otherwise
</span>        <span style="color: #e5786d;">dec</span> <span style="color: #cae682;">rdx</span>
        <span style="color: #e5786d;">not</span> <span style="color: #cae682;">rdx</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx is now 00h if it was 1, and FFFFFFFFFFFFFFFFh otherwise
</span>
<span style="color: #99968b;">;; </span><span style="color: #99968b;">set rax to '0' if rdx is 1, and NULL otherwise
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rdx</span>
        <span style="color: #e5786d;">not</span> <span style="color: #cae682;">rax</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rax</span>, <span style="color: #95e454;">'0'</span>

<span style="color: #99968b;">;; </span><span style="color: #99968b;">set rdx to '0' if it was 1, and 'z' otherwise
</span>        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rdx</span>, <span style="color: #95e454;">'z'</span> - <span style="color: #95e454;">'0'</span>
        <span style="color: #e5786d;">add</span> <span style="color: #cae682;">rdx</span>, <span style="color: #95e454;">'0'</span>

<span style="color: #99968b;">;; </span><span style="color: #99968b;">write our bytes
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">2</span>], <span style="color: #cae682;">dl</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">3</span>], <span style="color: #cae682;">dl</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">6</span>], <span style="color: #cae682;">dl</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">7</span>], <span style="color: #cae682;">dl</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">8</span>], <span style="color: #cae682;">al</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgfc03837" class="outline-4">
<h4 id="orgfc03837"><span class="section-number-4">2.4.8.</span> Byte 4</h4>
<div class="outline-text-4" id="text-2-4-8">
<p>
For byte 4, the only byte where we need to distinguish based on the intended output&rsquo;s <i>length,</i> we can use bit position
1 in <code>rdx</code> to distinguish <code>6</code> and <code>10</code> from <code>0</code> and <code>1</code> (it&rsquo;s set in the former and unset in the latter), and bit
position 0 (only set in the former, obviously) to distinguish <code>1</code> from <code>0</code>.
</p>

<p>
We are conveniently aided by the facts that, in terms of set bits, <code>'B'</code> and <code>'0'</code> are disjoint; and that <code>NULL</code> is
zeroed. This enables us to use a simplified form of the three-option procedure.
</p>

<div class="org-center">
<p>
Registers:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Copy of the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; procedure result, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Scratch register, used to compose conditional masks</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Value to write to buffer offset 4</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm">        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rcx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">restore rdx
</span>        <span style="color: #e5786d;">xor</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rax</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">zero rax, we'll compose our result in here
</span><span style="color: #99968b;">;; </span><span style="color: #99968b;">set up as though this weren't 6 or 10
</span>        <span style="color: #e5786d;">dec</span> <span style="color: #cae682;">rdx</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx is now 00h if it was 1, and FFFFFFFFFFFFFFFFh if it was 0
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rax</span>, <span style="color: #95e454;">'B'</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rdx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">rax is now 'B' if rdx was 0 and 00h if rdx was 1
</span>        <span style="color: #e5786d;">not</span> <span style="color: #cae682;">rdx</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rdx</span>, <span style="color: #95e454;">'0'</span>
        <span style="color: #e5786d;">or</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rdx</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">rax is now '0' if rdx was 1 and unchanged if rdx was 0
</span><span style="color: #99968b;">;; </span><span style="color: #99968b;">"is it 0 or 1" mask
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rcx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">restore rdx
</span>        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rdx</span>, <span style="color: #e5786d;">00000010b</span>
        <span style="color: #e5786d;">sub</span> <span style="color: #cae682;">rdx</span>, <span style="color: #e5786d;">00000010b</span>      <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx is now 00h if it was &gt; 1, else FFFFFFFFFFFFFFFFh
</span>        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rdx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">rax is now 00h (NULL) if rdx was &gt; 1
</span><span style="color: #99968b;">;; </span><span style="color: #99968b;">write our byte
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">4</span>], <span style="color: #cae682;">al</span>

</pre>
</div>
</div>
</div>
<div id="outline-container-org240b6ee" class="outline-4">
<h4 id="org240b6ee"><span class="section-number-4">2.4.9.</span> &ldquo;Fizz vs Buzz vs <code>itoa</code>&rdquo;</h4>
<div class="outline-text-4" id="text-2-4-9">
<p>
Finally, for bytes 0, 1 and 5, we need to discriminate based on whether <code>rdx</code> is equal to <code>1</code>, or if it&rsquo;s equal to <code>10</code>,
or if it&rsquo;s equal to <code>0</code> or <code>6</code>.
</p>

<p>
To distinguish <code>0</code> and <code>6</code> from <code>1</code> and <code>10</code>, we can decrement <code>rdx</code> and check if bit 2 is <code>1</code>. If it is, it&rsquo;s <code>0</code> or
<code>6</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left"><code>dl</code></th>
<th scope="col" class="org-left"><code>dl - 1</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>00000000</code></td>
<td class="org-left"><code>11111111</code></td>
</tr>

<tr>
<td class="org-left"><code>00000001</code></td>
<td class="org-left"><code>00000000</code></td>
</tr>

<tr>
<td class="org-left"><code>00000110</code></td>
<td class="org-left"><code>00000101</code></td>
</tr>

<tr>
<td class="org-left"><code>00001010</code></td>
<td class="org-left"><code>00001001</code></td>
</tr>
</tbody>
</table>

<p>
To distinguish <code>1</code>, we only have to look at the 0th bit of <code>rdx - 1</code>: it&rsquo;ll be set if it was <code>0</code>, <code>6</code> or <code>10</code>, and unset
if it was <code>1</code>.
</p>

<p>
From these two bit positions, we can calculate the proper character value. Conveniently, we can turn <code>'B'</code> into <code>'F'</code> by
setting the very same bit position, and the bits of <code>'0'</code> are mutually exclusive with those of either. <i>Unfortunately,</i>
&rsquo;i&rsquo; and &rsquo;u&rsquo; are overlapping non-subsets. &rsquo;u&rsquo; <i>is</i> a superset of &rsquo;0&rsquo;, though.
</p>

<p>
This logic is pretty involved, since we have three completely different results to compose and three possible options;
fortunately, since these are the last bytes and we don&rsquo;t need to restore <code>rdx</code> anymore, we can afford to clobber <code>rcx</code>
for another non-REX scratch register.
</p>

<div class="org-center">
<p>
Registers:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Name</th>
<th scope="col" class="org-left">Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>rdi</code></td>
<td class="org-left">Write-to-output-buffer pointer, held invariant</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rcx</code></td>
<td class="org-left">Copy of the &ldquo;Euler&rsquo;s FizzBuzz&rdquo; procedure result,</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">later re-used as the bit-unset mask for both-coprime results</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rdx</code></td>
<td class="org-left">Scratch, used to compose conditional masks</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>rax</code></td>
<td class="org-left">Value to write to buffer offset 0</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r8</code></td>
<td class="org-left">Value to write to buffer offset 1</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>r11</code></td>
<td class="org-left">Value to write to buffer offset 5</td>
</tr>
</tbody>
</table>
</div>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #99968b;">;; </span><span style="color: #99968b;">is it 0 or 6? or is it something else?
</span>        <span style="color: #e5786d;">dec</span> <span style="color: #cae682;">rcx</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rcx</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rax</span>, <span style="color: #e5786d;">00000100b</span>      <span style="color: #99968b;">; </span><span style="color: #99968b;">rax now contains 04h if rcx was 0 or 6, and 00h if it was 1 or 10
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rax</span>
        <span style="color: #e5786d;">or</span> <span style="color: #cae682;">rax</span>, <span style="color: #95e454;">'B'</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">rax now contains 'F' if rcx was 0 or 6, and 'B' if it was 1 or 10
</span>
        <span style="color: #e5786d;">shr</span> <span style="color: #cae682;">rdx</span>, <span style="color: #e5786d;">2</span>
        <span style="color: #e5786d;">dec</span> <span style="color: #cae682;">rdx</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rdx now contains 00h if rcx was 0 or 6, and FFFFFFFFFFFFFFFFh if it was 1 or 10
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">r8</span>, <span style="color: #95e454;">'u'</span> - <span style="color: #95e454;">'0'</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">r8</span>, <span style="color: #cae682;">rdx</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">r8 now contains 'u' - '0' if rcx was 1 or 10, and 00h if it was 0 or 6
</span>        <span style="color: #e5786d;">not</span> <span style="color: #cae682;">rdx</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">r11</span>, <span style="color: #cae682;">rdx</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rdx</span>, <span style="color: #95e454;">'i'</span> - <span style="color: #95e454;">'0'</span>
        <span style="color: #e5786d;">or</span> <span style="color: #cae682;">r8</span>, <span style="color: #cae682;">rdx</span>              <span style="color: #99968b;">; </span><span style="color: #99968b;">r8 now contains 'i' - '0' if rcx was 0 or 6, and is unchanged if it was 1 or 10
</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">r11</span>, <span style="color: #95e454;">'u'</span>
        <span style="color: #e5786d;">or</span> <span style="color: #cae682;">r11</span>, <span style="color: #95e454;">'0'</span>              <span style="color: #99968b;">; </span><span style="color: #99968b;">r11 now contains 'u' if rcx was 0 or 6, and '0' if it was 1 or 10
</span><span style="color: #99968b;">;; </span><span style="color: #99968b;">write byte 5
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">5</span>], <span style="color: #cae682;">r11b</span>

<span style="color: #99968b;">;; </span><span style="color: #99968b;">but was it 1 all along?
</span>        <span style="color: #e5786d;">not</span> <span style="color: #cae682;">rcx</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rcx</span>, <span style="color: #e5786d;">00000001b</span>      <span style="color: #99968b;">; </span><span style="color: #99968b;">rcx now contains 01h if it was 1, and 00h otherwise
</span>        <span style="color: #e5786d;">dec</span> <span style="color: #cae682;">rcx</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rcx now contains 00h if our initial rcx value was 1, and FFFFFFFFFFFFFFFFh otherwise
</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">r8</span>, <span style="color: #cae682;">rcx</span>
        <span style="color: #e5786d;">add</span> <span style="color: #cae682;">r8</span>, <span style="color: #95e454;">'0'</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">r8 now contains '0' if our initial rcx value was 1, 'u' if it was 10, and 'i' if it was 0 or 6
</span>
<span style="color: #99968b;">;; </span><span style="color: #99968b;">write byte 1
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span> + <span style="color: #e5786d;">1</span>], <span style="color: #cae682;">r8b</span>

<span style="color: #99968b;">;; </span><span style="color: #99968b;">wrap up "was it 1 all along?"
</span>        <span style="color: #e5786d;">not</span> <span style="color: #cae682;">rcx</span>                 <span style="color: #99968b;">; </span><span style="color: #99968b;">rcx now contains FFFFFFFFFFFFFFFFh if our initial rcx value was 1, and 00h otherwise
</span>
        <span style="color: #e5786d;">mov</span> <span style="color: #cae682;">rdx</span>, <span style="color: #cae682;">rcx</span>
        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rdx</span>, <span style="color: #95e454;">'0'</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">our *set* mask
</span>        <span style="color: #e5786d;">and</span> <span style="color: #cae682;">rcx</span>, <span style="color: #cae682;">rax</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">our *unset* mask
</span>

        <span style="color: #e5786d;">xor</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rcx</span>            <span style="color: #99968b;">; </span><span style="color: #99968b;">sets rax to 0 if our initial rcx value was 1, otherwise leaves it unchanged
</span>        <span style="color: #e5786d;">or</span> <span style="color: #cae682;">rax</span>, <span style="color: #cae682;">rdx</span>             <span style="color: #99968b;">; </span><span style="color: #99968b;">sets rax to '0' if our initial rcx value was 1, otherwise leaves it unchanged
</span>
<span style="color: #99968b;">;; </span><span style="color: #99968b;">write byte 0
</span>        <span style="color: #e5786d;">mov</span> <span style="color: #92a65e; font-weight: bold;">byte</span> [<span style="color: #cae682;">rdi</span>], <span style="color: #cae682;">al</span>
</pre>
</div>

<p>
And with that, we&rsquo;re all done!
</p>

<div class="org-src-container">
<pre class="src src-nasm"><span style="color: #e5786d;">ret</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org505df75" class="outline-2">
<h2 id="org505df75"><span class="section-number-2">3.</span> Building</h2>
<div class="outline-text-2" id="text-3">
<p>
This project requires make, YASM, gcc, and mkdir for building, and targets only systems which use the System V ABI.
</p>

<p>
To build, just clone the repo, navigate to the root directory, and run <code>make</code>. The binary will be located at
<code>build/branchless_fizzbuzz</code>.
</p>

<p>
To remove all build products from the build directory, run <code>make clean</code>. To remove all build products <i>and</i> the binary
from the build directory, run <code>make pristine</code>.
</p>
</div>
</div>
<div id="outline-container-org1bad688" class="outline-2">
<h2 id="org1bad688"><span class="section-number-2">4.</span> Potential Further Improvements</h2>
<div class="outline-text-2" id="text-4">
<p>
There are two obvious avenues of &ldquo;improvement&rdquo; that I&rsquo;m not going to take. They are as follows:
</p>

<ol class="org-ol">
<li>Replace the loop in the C driver with a <code>%rep</code> loop in the assembly portion of the project. If taken with #1, would
probably involve passing a pair of buffers: one to write data to, and another to write pointers to the starts of each
string. First buffer should probably be 32-byte aligned.</li>
<li>Have the assembly portion return a pointer the beginning of the string, instead of just <i>assuming</i> it&rsquo;s the same as
the start of the buffer, to allow elision of all those leading 0s.</li>
</ol>

<p>
Refusing the first is, I think, easy pretty easy to justify: <b>it doesn&rsquo;t actually get rid of the loop in the driver.</b> We
still have to go through all those strings! It would balloon the size of the binary for no benefit to purity.
</p>

<p>
We could unroll this outer loop, of course, but we could do that without unrolling it inside <code>bfb_fill_buffer</code> too. The
only <i>actual</i> purity benefit from this change would be the reduction in the number of calls to <code>bfb_fill_buffer</code>, down
to just one. Ehhhhh.
</p>

<p>
I reject the second &ldquo;improvement&rdquo; for a very different reason: it makes the problem too easy. If we can control the
string window in the output buffer, our byte offset decision table simplifies down to this:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-left" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>dl</code></th>
<th scope="col" class="org-left">byte</th>
<th scope="col" class="org-center">0</th>
<th scope="col" class="org-center">1</th>
<th scope="col" class="org-center">2</th>
<th scope="col" class="org-center">3</th>
<th scope="col" class="org-center">4</th>
<th scope="col" class="org-center">5</th>
<th scope="col" class="org-center">6</th>
<th scope="col" class="org-center">7</th>
<th scope="col" class="org-center">8</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">&#xa0;</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
</tr>
</tbody>
</table>

<p>
or even <i>this:</i>
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />
</colgroup>

<colgroup>
<col  class="org-left" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right"><code>dl</code></th>
<th scope="col" class="org-left">byte</th>
<th scope="col" class="org-center">0</th>
<th scope="col" class="org-center">1</th>
<th scope="col" class="org-center">2</th>
<th scope="col" class="org-center">3</th>
<th scope="col" class="org-center">4</th>
<th scope="col" class="org-center">5</th>
<th scope="col" class="org-center">6</th>
<th scope="col" class="org-center">7</th>
<th scope="col" class="org-center">8</th>
<th scope="col" class="org-center">9</th>
<th scope="col" class="org-center">10</th>
<th scope="col" class="org-center">11</th>
<th scope="col" class="org-center">12</th>
<th scope="col" class="org-center">13</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">&#xa0;</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">&#xa0;</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">&#xa0;</td>
<td class="org-center"><code>'F'</code></td>
<td class="org-center"><code>'i'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">&#xa0;</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center">?</td>
<td class="org-center"><code>'B'</code></td>
<td class="org-center"><code>'u'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>'z'</code></td>
<td class="org-center"><code>NULL</code></td>
</tr>
</tbody>
</table>

<p>
Besides the <code>itoa</code>, every byte offset can simply be set to a fixed value. The only problem to solve is the final
pointer, which while interesting isn&rsquo;t <i>that</i> interesting. We calculate the base 10 logarithm (probably on the FPU) of
the input, plus one; then either return it or some fixed value. Boring! I&rsquo;ll stick with my fixed width approach.
</p>

<p>
The ways I <i>would</i> be interested in improving this project are as follows:
</p>

<ol class="org-ol">
<li>Learn more about the x64 architecture and find cleverer ways to perform discrimination and option selection. Time to
read the Intel Developer&rsquo;s Manual cover to cover!</li>
<li>Somehow put the results into a single buffer with newlines separating results, instead of NULL terminators. This
seems very possible, as any given block of fifteen results will be the same size as any other block so long as their
starting and ending coprime numbers are of the same magnitude as the other&rsquo;s. Seems like a task for automated code
generation? We&rsquo;ll see about this one.</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-09-30 Tue 19:38</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
